#!/usr/bin/env python3
"""
Programa para gerar arquivo final mesclando teaser com BGM + v√≠deo concatenado
Etapa 4: Criar vers√£o final com teaser no in√≠cio + v√≠deo completo
"""

import os
import subprocess
from pathlib import Path
from datetime import datetime
import time

# =============================================================================
# CONFIGURA√á√ïES - ALTERE AQUI CONFORME NECESS√ÅRIO
# =============================================================================

# Diret√≥rios
INPUT_DIR = "output"
OUTPUT_DIR = "output"

# Configura√ß√µes de v√≠deo - ULTRA OTIMIZADO PARA 4K
# NOTA: Usando copy codec - SEM re-encodifica√ß√£o!

# =============================================================================

def validate_config():
    """Valida as configura√ß√µes do programa"""
    if not os.path.exists(INPUT_DIR):
        print(f"‚ùå Diret√≥rio de entrada '{INPUT_DIR}' n√£o encontrado!")
        return False
    return True

def get_video_properties(video_path):
    """Obt√©m propriedades detalhadas do v√≠deo usando ffprobe"""
    try:
        cmd = ['ffprobe', '-v', 'quiet', '-print_format', 'json', 
               '-show_format', '-show_streams', video_path]
        result = subprocess.run(cmd, capture_output=True, text=True)
        if result.returncode == 0:
            import json
            return json.loads(result.stdout)
    except Exception as e:
        print(f"    ‚ö†Ô∏è Erro ao obter propriedades: {e}")
    return None

def get_video_duration(video_path):
    """Obt√©m dura√ß√£o do v√≠deo usando ffprobe"""
    try:
        cmd = ['ffprobe', '-v', 'quiet', '-show_entries', 'format=duration', 
               '-of', 'default=noprint_wrappers=1:nokey=1', video_path]
        result = subprocess.run(cmd, capture_output=True, text=True)
        if result.returncode == 0:
            return float(result.stdout.strip())
    except:
        pass
    return None

def find_latest_teaser_with_bgm():
    """Encontra o teaser com BGM mais recente"""
    teaser_files = []
    for pattern in ['*teaser_with_bgm.mp4', '*teaser_with_bgm.MP4']:
        teaser_files.extend(Path(INPUT_DIR).glob(pattern))
    
    if not teaser_files:
        print(f"‚ùå Nenhum teaser com BGM encontrado na pasta '{INPUT_DIR}'")
        return None
    
    latest_teaser = max(teaser_files, key=lambda x: x.stat().st_mtime)
    print(f"    üìÅ Teaser com BGM selecionado: {latest_teaser.name}")
    return str(latest_teaser)

def find_latest_concatenated():
    """Encontra o v√≠deo concatenado mais recente"""
    video_files = []
    for pattern in ['*concatenated_videos.mp4', '*concatenated_videos.MP4']:
        video_files.extend(Path(INPUT_DIR).glob(pattern))
    
    if not video_files:
        print(f"‚ùå Nenhum v√≠deo concatenado encontrado na pasta '{INPUT_DIR}'")
        return None
    
    latest_video = max(video_files, key=lambda x: x.stat().st_mtime)
    print(f"    üìÅ V√≠deo concatenado selecionado: {latest_video.name}")
    return str(latest_video)

def check_video_compatibility(teaser_path, concatenated_path):
    """Verifica se os v√≠deos s√£o compat√≠veis para concatena√ß√£o"""
    print("üîç VERIFICANDO compatibilidade dos v√≠deos...")
    
    # Obter propriedades dos dois v√≠deos
    teaser_props = get_video_properties(teaser_path)
    concatenated_props = get_video_properties(concatenated_path)
    
    if not teaser_props or not concatenated_props:
        print("    ‚ùå N√£o foi poss√≠vel obter propriedades dos v√≠deos")
        return False
    
    # Verificar streams de v√≠deo
    teaser_video_streams = [s for s in teaser_props.get('streams', []) if s.get('codec_type') == 'video']
    concatenated_video_streams = [s for s in concatenated_props.get('streams', []) if s.get('codec_type') == 'video']
    
    if not teaser_video_streams or not concatenated_video_streams:
        print("    ‚ùå N√£o foram encontrados streams de v√≠deo")
        return False
    
    # Verificar streams de √°udio
    teaser_audio_streams = [s for s in teaser_props.get('streams', []) if s.get('codec_type') == 'audio']
    concatenated_audio_streams = [s for s in concatenated_props.get('streams', []) if s.get('codec_type') == 'audio']
    
    if not teaser_audio_streams or not concatenated_audio_streams:
        print("    ‚ùå N√£o foram encontrados streams de √°udio")
        return False
    
    # Comparar propriedades cr√≠ticas
    teaser_video = teaser_video_streams[0]
    concatenated_video = concatenated_video_streams[0]
    
    print(f"    üìä PROPRIEDADES DO TEASER:")
    print(f"      ‚Ä¢ Codec: {teaser_video.get('codec_name', 'N/A')}")
    print(f"      ‚Ä¢ Resolu√ß√£o: {teaser_video.get('width', 'N/A')}x{teaser_video.get('height', 'N/A')}")
    print(f"      ‚Ä¢ FPS: {teaser_video.get('r_frame_rate', 'N/A')}")
    print(f"      ‚Ä¢ Bitrate: {teaser_video.get('bit_rate', 'N/A')}")
    
    print(f"    üìä PROPRIEDADES DO V√çDEO CONCATENADO:")
    print(f"      ‚Ä¢ Codec: {concatenated_video.get('codec_name', 'N/A')}")
    print(f"      ‚Ä¢ Resolu√ß√£o: {concatenated_video.get('width', 'N/A')}x{concatenated_video.get('height', 'N/A')}")
    print(f"      ‚Ä¢ FPS: {concatenated_video.get('r_frame_rate', 'N/A')}")
    print(f"      ‚Ä¢ Bitrate: {concatenated_video.get('bit_rate', 'N/A')}")
    
    # Verificar compatibilidade
    compatible = True
    if teaser_video.get('codec_name') != concatenated_video.get('codec_name'):
        print(f"    ‚ö†Ô∏è Codecs diferentes: {teaser_video.get('codec_name')} vs {concatenated_video.get('codec_name')}")
        compatible = False
    
    if teaser_video.get('width') != concatenated_video.get('width') or teaser_video.get('height') != concatenated_video.get('height'):
        print(f"    ‚ö†Ô∏è Resolu√ß√µes diferentes: {teaser_video.get('width')}x{teaser_video.get('height')} vs {concatenated_video.get('width')}x{concatenated_video.get('height')}")
        compatible = False
    
    if teaser_video.get('r_frame_rate') != concatenated_video.get('r_frame_rate'):
        print(f"    ‚ö†Ô∏è FPS diferentes: {teaser_video.get('r_frame_rate')} vs {concatenated_video.get('r_frame_rate')}")
        compatible = False
    
    if compatible:
        print("    ‚úÖ V√≠deos s√£o compat√≠veis para concatena√ß√£o!")
    else:
        print("    ‚ö†Ô∏è V√≠deos t√™m propriedades diferentes - concat demuxer pode falhar")
    
    return compatible

def create_final_video(teaser_path, concatenated_path, output_path):
    """Cria v√≠deo final: teaser + v√≠deo concatenado"""
    print("üé¨ Passo 2/2: CRIANDO v√≠deo final (teaser + v√≠deo completo)...")
    merge_start = time.time()
    
    # Verificar compatibilidade antes de prosseguir
    if not check_video_compatibility(teaser_path, concatenated_path):
        print("    ‚ö†Ô∏è Continuando mesmo com incompatibilidades...")
    
    # Obter dura√ß√µes para debug
    teaser_duration = get_video_duration(teaser_path)
    concatenated_duration = get_video_duration(concatenated_path)
    
    print(f"    üîç DEBUG - Dura√ß√£o do teaser: {teaser_duration:.1f}s" if teaser_duration else "    üîç DEBUG - N√£o foi poss√≠vel obter dura√ß√£o do teaser")
    print(f"    üîç DEBUG - Dura√ß√£o do v√≠deo concatenado: {concatenated_duration:.1f}s" if concatenated_duration else "    üîç DEBUG - N√£o foi poss√≠vel obter dura√ß√£o do v√≠deo concatenado")
    
    if teaser_duration and concatenated_duration:
        expected_duration = teaser_duration + concatenated_duration
        print(f"    üîç DEBUG - Dura√ß√£o esperada do resultado: {expected_duration:.1f}s ({expected_duration/60:.1f} min)")
    
    # Criar arquivo de lista para concat demuxer
    list_file = os.path.join(OUTPUT_DIR, "final_video_list.txt")
    with open(list_file, 'w') as f:
        f.write(f"file '{os.path.abspath(teaser_path)}'\n")
        f.write(f"file '{os.path.abspath(concatenated_path)}'\n")
    
    # DEBUG: Mostrar conte√∫do do arquivo de lista
    print(f"    üîç DEBUG - Conte√∫do do arquivo de lista:")
    with open(list_file, 'r') as f:
        for i, line in enumerate(f, 1):
            print(f"      {i}: {line.strip()}")
    
    # Comando FFmpeg para concatenar teaser + v√≠deo concatenado (SEM re-encodifica√ß√£o!)
    cmd = [
        'ffmpeg', '-y',
        '-f', 'concat',
        '-safe', '0',
        '-i', list_file,
        '-c', 'copy',  # Apenas copy codec - SEM re-encodifica√ß√£o!
        '-avoid_negative_ts', 'make_zero',
        output_path
    ]
    
    print(f"    üîß Mesclando teaser + v√≠deo completo...")
    print(f"    üîç DEBUG - Comando: {' '.join(cmd)}")
    
    result = subprocess.run(cmd, capture_output=True, text=True)
    
    # DEBUG: Mostrar stderr se houver
    if result.stderr:
        print(f"    üîç DEBUG - FFmpeg stderr: {result.stderr}")
    
    # Limpar arquivo de lista
    if os.path.exists(list_file):
        os.remove(list_file)
    
    if result.returncode != 0:
        print(f"    ‚ùå Erro na mesclagem: {result.stderr}")
        return False
    
    # DEBUG: Verificar dura√ß√£o do arquivo final
    final_duration = get_video_duration(output_path)
    print(f"    üîç DEBUG - Dura√ß√£o do arquivo final: {final_duration:.1f}s ({final_duration/60:.1f} min)" if final_duration else "    üîç DEBUG - N√£o foi poss√≠vel obter dura√ß√£o do arquivo final")
    
    if final_duration and teaser_duration and concatenated_duration:
        expected_duration = teaser_duration + concatenated_duration
        if abs(final_duration - expected_duration) > 1.0:  # Toler√¢ncia de 1 segundo
            print(f"    ‚ö†Ô∏è ATEN√á√ÉO: Dura√ß√£o final ({final_duration:.1f}s) diferente da esperada ({expected_duration:.1f}s)")
        else:
            print(f"    ‚úÖ Dura√ß√£o final correta!")
    
    merge_time = time.time() - merge_start
    print(f"‚úÖ MESCLAGEM conclu√≠da em {format_time(merge_time)}")
    return True

def format_time(seconds):
    """Formata tempo em HH:MM:SS"""
    hours = int(seconds // 3600)
    minutes = int((seconds % 3600) // 60)
    secs = int(seconds % 60)
    return f"{hours:02d}:{minutes:02d}:{secs:02d}"

def main():
    start_time = time.time()
    
    # Validar configura√ß√µes
    if not validate_config():
        return
    
    print("üé¨ ETAPA 4: Cria√ß√£o do Arquivo Final")
    print("‚è±Ô∏è  Resolu√ß√£o: ORIGINAL (4K) - SEM REDIMENSIONAMENTO")
    print("üîß Codec: COPY - SEM re-encodifica√ß√£o!")
    print("üöÄ ULTRA OTIMIZADO: Teaser + V√≠deo Completo = Arquivo Final!")
    print("=" * 60)
    
    # Encontrar teaser com BGM mais recente
    teaser_path = find_latest_teaser_with_bgm()
    if not teaser_path:
        return
    
    print(f"üìπ Teaser com BGM: {os.path.basename(teaser_path)}")
    
    # Encontrar v√≠deo concatenado mais recente
    concatenated_path = find_latest_concatenated()
    if not concatenated_path:
        return
    
    print(f"üìπ V√≠deo concatenado: {os.path.basename(concatenated_path)}")
    
    # Gerar nome do arquivo final
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    output_filename = f"{timestamp}_FINAL_teaser_plus_full_video.mp4"
    output_path = os.path.join(OUTPUT_DIR, output_filename)
    
    # Criar v√≠deo final
    if not create_final_video(teaser_path, concatenated_path, output_path):
        print("‚ùå Erro ao criar arquivo final!")
        return
    
    # Resultado final
    total_time = time.time() - start_time
    print("\n" + "=" * 60)
    print("‚úÖ ARQUIVO FINAL gerado com sucesso!")
    print(f"üìÅ Arquivo: {output_path}")
    print(f"üé¨ Estrutura: Teaser com BGM + V√≠deo Completo")
    print(f"‚è±Ô∏è  Tempo total: {format_time(total_time)}")
    
    if os.path.exists(output_path):
        file_size = os.path.getsize(output_path) / (1024 * 1024)
        print(f"üìä Tamanho: {file_size:.2f} MB")
    
    print("\nüöÄ OTIMIZA√á√ïES APLICADAS:")
    print("   ‚Ä¢ CONCATENA√á√ÉO inteligente de teaser + v√≠deo completo")
    print("   ‚Ä¢ QUALIDADE 4K mantida")
    print("   ‚Ä¢ COPY CODEC - SEM re-encodifica√ß√£o!")
    print("   ‚Ä¢ ESTRUTURA: Teaser (com BGM) + V√≠deo Original")

if __name__ == "__main__":
    main()
#!/usr/bin/env python3
"""
Programa para concatenar v√≠deos da pasta sources na pasta output
Etapa 1C: Trim, concatena√ß√£o e normaliza√ß√£o em 3 passos separados
"""

import os
import subprocess
import glob
import tempfile
from pathlib import Path
from datetime import datetime
import time

# =============================================================================
# CONFIGURA√á√ïES - ALTERE AQUI CONFORME NECESS√ÅRIO
# =============================================================================

# Diret√≥rios
SOURCES_DIR = "sources"
OUTPUT_DIR = "output"

# Limita√ß√µes
MAX_VIDEOS = 59
TRIM_SECONDS = 1.0

# Extens√µes de v√≠deo suportadas
VIDEO_EXTENSIONS = ['*.mp4', '*.MP4', '*.avi', '*.mov', '*.mkv']

# Configura√ß√µes de v√≠deo - MANTER RESOLU√á√ÉO ORIGINAL (4K)
OUTPUT_WIDTH = None  # Manter largura original
OUTPUT_HEIGHT = None  # Manter altura original

# Configura√ß√µes de codec de v√≠deo - USAR COPY (sem re-encodifica√ß√£o)
VIDEO_CODEC = 'copy'  # Copia sem re-encodificar
VIDEO_PRESET = None   # N√£o aplic√°vel com copy
VIDEO_QUALITY = None  # N√£o aplic√°vel com copy

# Configura√ß√µes de √°udio
AUDIO_CODEC = 'aac'
AUDIO_BITRATE = '128k'

# Configura√ß√µes de fade e normaliza√ß√£o
FADE_IN_DURATION = 1.0  # Dura√ß√£o do fade in em segundos (in√≠cio do v√≠deo)
USE_LOUDNORM = False  # True = aplicar normaliza√ß√£o loudnorm | False = apenas fade in

# Construir filtro de √°udio baseado nas configura√ß√µes
if USE_LOUDNORM:
    AUDIO_FILTER = f'afade=t=in:st=0:d={FADE_IN_DURATION},loudnorm'  # Fade in + normaliza√ß√£o
else:
    AUDIO_FILTER = f'afade=t=in:st=0:d={FADE_IN_DURATION}'  # Apenas fade in

# =============================================================================

def validate_config():
    """Valida as configura√ß√µes do programa"""
    if not os.path.exists(SOURCES_DIR):
        print(f"‚ùå Diret√≥rio de origem '{SOURCES_DIR}' n√£o encontrado!")
        return False
    
    if MAX_VIDEOS <= 0:
        print("‚ùå MAX_VIDEOS deve ser maior que 0!")
        return False
    
    if TRIM_SECONDS < 0:
        print("‚ùå TRIM_SECONDS deve ser maior ou igual a 0!")
        return False
    
    if OUTPUT_WIDTH is not None and (OUTPUT_WIDTH <= 0 or OUTPUT_HEIGHT <= 0):
        print("‚ùå Dimens√µes de sa√≠da devem ser maiores que 0!")
        return False
    
    return True

def get_video_duration(video_path):
    """Obt√©m a dura√ß√£o de um v√≠deo usando ffprobe"""
    cmd = [
        'ffprobe',
        '-v', 'quiet',
        '-show_entries', 'format=duration',
        '-of', 'csv=p=0',
        video_path
    ]
    result = subprocess.run(cmd, capture_output=True, text=True)
    if result.returncode != 0:
        return None
    return float(result.stdout.strip())

def trim_video(input_video, output_video, apply_fade_in=False):
    """Aplica trim em um v√≠deo e opcionalmente fade in (apenas para o primeiro v√≠deo)"""
    duration = get_video_duration(input_video)
    if duration is None:
        print(f"    ‚ùå Erro: N√£o foi poss√≠vel obter dura√ß√£o de {input_video}")
        return False
    
    end_time = duration - TRIM_SECONDS
    
    if apply_fade_in:
        # Primeiro v√≠deo: trim + fade in (mais eficiente aplicar aqui!)
        cmd_trim = [
            'ffmpeg', '-y',
            '-i', input_video,
            '-ss', str(TRIM_SECONDS),
            '-to', str(end_time),
            '-c:v', 'copy',  # V√≠deo sem re-encodificar
            '-af', f'afade=t=in:st=0:d={FADE_IN_DURATION}',  # Fade in no √°udio
            '-c:a', AUDIO_CODEC,
            '-b:a', AUDIO_BITRATE,
            output_video
        ]
    else:
        # Demais v√≠deos: apenas trim (copy codec)
        cmd_trim = [
            'ffmpeg', '-y',
            '-i', input_video,
            '-ss', str(TRIM_SECONDS),
            '-to', str(end_time),
            '-c', 'copy',
            output_video
        ]
    
    result = subprocess.run(cmd_trim, capture_output=True, text=True)
    if result.returncode != 0:
        print(f"    ‚ùå Erro no trim: {result.stderr}")
        return False
    
    return True

def concat_videos(video_list, output_video):
    """Concatena uma lista de v√≠deos (SEM normaliza√ß√£o) - MANT√âM RESOLU√á√ÉO ORIGINAL"""
    if len(video_list) == 1:
        # Apenas 1 v√≠deo, copia
        cmd = [
            'ffmpeg', '-y', 
            '-i', video_list[0],
            '-c', 'copy',  # Copia tudo sem re-encodificar
            output_video
        ]
    else:
        # M√∫ltiplos v√≠deos, concatena com copy (mesma resolu√ß√£o)
        # Criar arquivo de lista para concatena√ß√£o mais eficiente
        list_file = output_video.replace('.mp4', '_list.txt')
        
        with open(list_file, 'w') as f:
            for video in video_list:
                # Usar caminho absoluto para evitar problemas
                abs_path = os.path.abspath(video)
                f.write(f"file '{abs_path}'\n")
        
        cmd = [
            'ffmpeg', '-y',
            '-f', 'concat',
            '-safe', '0',
            '-i', list_file,
            '-c', 'copy',  # Copia tudo sem re-encodificar
            output_video
        ]
        
        result = subprocess.run(cmd, capture_output=True, text=True)
        
        # Limpar arquivo de lista
        if os.path.exists(list_file):
            os.remove(list_file)
        
        if result.returncode != 0:
            print(f"    ‚ùå Erro na concatena√ß√£o: {result.stderr}")
        return result.returncode == 0

def normalize_audio(input_video, output_video):
    """Aplica normaliza√ß√£o de √°udio em um v√≠deo (loudnorm, sem fade in pois j√° foi aplicado)"""
    if USE_LOUDNORM:
        # Aplicar apenas loudnorm (fade in j√° foi aplicado no primeiro v√≠deo!)
        cmd = [
            'ffmpeg', '-y',
            '-i', input_video,
            '-c:v', 'copy',  # Copia v√≠deo sem re-encodificar
            '-af', 'loudnorm',  # Apenas normaliza√ß√£o, sem fade in
            '-c:a', AUDIO_CODEC,
            '-b:a', AUDIO_BITRATE,
            output_video
        ]
    else:
        # Sem loudnorm: apenas copiar (fade in j√° foi aplicado no primeiro v√≠deo!)
        cmd = [
            'ffmpeg', '-y',
            '-i', input_video,
            '-c', 'copy',  # Copiar tudo sem processar
            output_video
        ]
    
    result = subprocess.run(cmd, capture_output=True, text=True)
    return result.returncode == 0

def format_time(seconds):
    """Formata tempo em HH:MM:SS"""
    hours = int(seconds // 3600)
    minutes = int((seconds % 3600) // 60)
    secs = int(seconds % 60)
    return f"{hours:02d}:{minutes:02d}:{secs:02d}"

def main():
    start_time = time.time()
    
    # Validar configura√ß√µes
    if not validate_config():
        return
    
    os.makedirs(OUTPUT_DIR, exist_ok=True)

    # Encontrar v√≠deos
    video_files = []
    for ext in VIDEO_EXTENSIONS:
        video_files.extend(glob.glob(os.path.join(SOURCES_DIR, ext)))
    video_files = list(set(video_files))
    video_files.sort()

    if not video_files:
        print(f"‚ùå Nenhum arquivo de v√≠deo encontrado na pasta '{SOURCES_DIR}'")
        return

    if len(video_files) > MAX_VIDEOS:
        print(f"‚ö†Ô∏è  Encontrados {len(video_files)} v√≠deos, limitando a {MAX_VIDEOS}")
        video_files = video_files[:MAX_VIDEOS]

    print(f"üìπ Processando {len(video_files)} v√≠deos")
    print(f"‚è±Ô∏è  Resolu√ß√£o: ORIGINAL (4K) - SEM REDIMENSIONAMENTO")
    print(f"üîß Trim: {TRIM_SECONDS}s | Codec: {VIDEO_CODEC} | √Åudio: {AUDIO_CODEC}")
    print(f"üéöÔ∏è  Fade In: {FADE_IN_DURATION}s (aplicado no PRIMEIRO v√≠deo)")
    
    if USE_LOUDNORM:
        print(f"üîä Normaliza√ß√£o: loudnorm aplicado no v√≠deo final")
    else:
        print(f"‚ö° SEM normaliza√ß√£o (apenas copy - m√°xima velocidade!)")
    
    print("üöÄ ULTRA OTIMIZADO: Copy codec + resolu√ß√£o original + fade in otimizado!")
    print("=" * 60)

    # Passo 1: Apenas trim dos v√≠deos (sem normaliza√ß√£o)
    print("üîÑ Passo 1/3: Aplicando TRIM nos v√≠deos...")
    processed_videos = []
    trim_start = time.time()
    
    for i, video in enumerate(video_files, 1):
        elapsed = time.time() - start_time
        
        # Indicar se √© o primeiro v√≠deo (aplicar fade in)
        is_first = (i == 1)
        video_info = f"  {i}/{len(video_files)}: {os.path.basename(video)}"
        if is_first:
            video_info += " [FADE IN]"
        print(f"{video_info} - {format_time(elapsed)}")
        
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S_%f")
        processed_file = os.path.join(OUTPUT_DIR, f"trimmed_{i:02d}_{timestamp}_{os.path.basename(video)}")
        
        # Aplicar fade in apenas no primeiro v√≠deo!
        if not trim_video(video, processed_file, apply_fade_in=is_first):
            print(f"‚ùå Erro ao processar {os.path.basename(video)}")
            return
        
        processed_videos.append(processed_file)

    trim_time = time.time() - trim_start
    print(f"‚úÖ TRIM conclu√≠do em {format_time(trim_time)}")

    # Passo 2: Concatenar v√≠deos (sem normaliza√ß√£o)
    print(f"\nüîÑ Passo 2/3: CONCATENANDO v√≠deos...")
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    temp_concat = os.path.join(OUTPUT_DIR, f"temp_{timestamp}_concatenated.mp4")
    
    concat_start = time.time()
    print(f"  üìé Concatenando {len(processed_videos)} v√≠deos...")
    
    if not concat_videos(processed_videos, temp_concat):
        print("‚ùå Erro na concatena√ß√£o")
        return
    
    concat_time = time.time() - concat_start
    print(f"‚úÖ CONCATENA√á√ÉO conclu√≠da em {format_time(concat_time)}")

    # Passo 3: Normalizar √°udio do v√≠deo concatenado (fade in j√° foi aplicado!)
    if USE_LOUDNORM:
        print(f"\nüîÑ Passo 3/3: NORMALIZANDO √°udio do v√≠deo final...")
    else:
        print(f"\nüîÑ Passo 3/3: FINALIZANDO v√≠deo concatenado...")
    
    final_output = os.path.join(OUTPUT_DIR, f"{timestamp}_concatenated_videos.mp4")
    
    normalize_start = time.time()
    
    if USE_LOUDNORM:
        print(f"  üîä Aplicando loudnorm no √°udio (fade in j√° aplicado)...")
    else:
        print(f"  üìã Copiando v√≠deo final (fade in j√° aplicado)...")
    
    if not normalize_audio(temp_concat, final_output):
        if USE_LOUDNORM:
            print("‚ùå Erro na normaliza√ß√£o")
        else:
            print("‚ùå Erro ao finalizar v√≠deo")
        return
    
    normalize_time = time.time() - normalize_start
    
    if USE_LOUDNORM:
        print(f"‚úÖ NORMALIZA√á√ÉO conclu√≠da em {format_time(normalize_time)}")
    else:
        print(f"‚úÖ V√çDEO FINAL copiado em {format_time(normalize_time)}")

    # Limpeza do arquivo tempor√°rio
    if os.path.exists(temp_concat):
        os.remove(temp_concat)

    # Resultado final
    total_time = time.time() - start_time
    print("\n" + "=" * 60)
    print("‚úÖ Processamento conclu√≠do com sucesso!")
    print(f"üìÅ Arquivo final: {final_output}")
    print(f"‚è±Ô∏è  Tempo total: {format_time(total_time)}")
    print(f"üìä Breakdown dos tempos:")
    print(f"   ‚Ä¢ TRIM (fade in no 1¬∫ v√≠deo): {format_time(trim_time)}")
    print(f"   ‚Ä¢ CONCATENA√á√ÉO: {format_time(concat_time)}")
    
    if USE_LOUDNORM:
        print(f"   ‚Ä¢ NORMALIZA√á√ÉO (loudnorm): {format_time(normalize_time)}")
    else:
        print(f"   ‚Ä¢ FINALIZA√á√ÉO (copy): {format_time(normalize_time)}")
    
    if os.path.exists(final_output):
        file_size = os.path.getsize(final_output) / (1024 * 1024)
        print(f"üìä Tamanho: {file_size:.2f} MB")
    
    # Limpeza
    print("\nüßπ Limpando arquivos tempor√°rios...")
    for video in processed_videos:
        if os.path.exists(video):
            os.remove(video)
    print("‚úÖ Limpeza conclu√≠da!")
    print("\nüöÄ ULTRA OTIMIZA√á√ÉO APLICADA:")
    print("   ‚Ä¢ TRIM r√°pido (copy codec)")
    print(f"   ‚Ä¢ FADE IN ({FADE_IN_DURATION}s) aplicado no PRIMEIRO v√≠deo (muito mais r√°pido!)")
    print("   ‚Ä¢ CONCATENA√á√ÉO com resolu√ß√£o 4K original")
    
    if USE_LOUDNORM:
        print("   ‚Ä¢ NORMALIZA√á√ÉO loudnorm apenas no v√≠deo final")
    else:
        print("   ‚Ä¢ SEM normaliza√ß√£o (apenas copy - instant√¢neo!)")
    
    print("   ‚Ä¢ ZERO re-encodifica√ß√£o desnecess√°ria")
    print("   ‚Ä¢ Etapa 2 ser√° 100x mais r√°pida!")

if __name__ == "__main__":
    main()
